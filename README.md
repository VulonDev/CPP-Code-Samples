# CPP-Code-Samples
C++ samples created to show that yes, I do really know the language! The rest of my GitHub is mostly games projects which have not used C++, so I've added this to show experience there.


#Cat and Mouse Maze Code Sample Info

Simulates a cat chasing a mouse through a maze. Sometimes the cat will catch the mouse, other times the mouse will reach the exit and escape. The simulation runs 10 times by default, which can be modified by altering the variable in main().
Interesting tidbit: With the current implemenentation, the cat will usually catch the mouse roughly one third of the time.

The maze is represented as an unweighted graph with the following constraints: 
- The maze is constructed with x total nodes, where x defaults to 30, but can be changed by altering the variable set in main().
- There is a START node, node 0, which represents the entrance to the maze.
- There is an EXIT node, node (x - 1), which represents the end of the maze.
- Each node within the maze must have at least one edge to another node.
- Each node within the maze cannot have more than four edges to other nodes.
- A node cannot connect to itself.
- An edge directly between START and EXIT is forbidden.

The maze is generated using a version of DFS in which edges are generated by visiting each node in a random order and adding edges in line with the constraints.
After the maze is generated, a post-processing step iterates over the maze one more time to ensure that each node is connected to at least one other node (valid edges only).

Representing a graph in console input is difficult, but maze information can be printed as a list of each node and which other nodes each has edges to.

The mouse and cat move through the maze, traversing one node at a time. When the simulation starts, the mouse starts at node 0 and is given two moves before the cat spawns at node 0. 
Then, the mouse moves and then the cat, back and forth, checking after each cycle if the cat has caught the mouse or if the mouse has escaped.
In cases where the mouse reaches the exit node and then the cat reaches that same node on the same turn as the mouse, the mouse's escape is given priority and the mouse wins.

The mouse moves between nodes with the following logic:
- The mouse may only move from its current node to an adjacent node.
- The mouse leaves a scent trail with decreasing intensity over its current node, its previous node, and the node before that.
- Under ordinary circumstances, the mouse will randomly select an adjacent node to wander to, excluding the node it just left on its prior move unless it has no other option.
- However, if the mouse detects the cat on an adjacent node, the mouse will panic. When panicked, the mouse searches for the most direct path to the exit - using BFS - and then moves in that direction.
- If the mouse ends its turn on the exit node, it successfully escapes.

The cat moves between nodes with the following logic:
- The cat may only move from its current node to an adjacent node.
- If the cat's current node is present in the mouse's scent trail, the cat will select one random adjacent node to investigate for a STRONGER scent trail.
- If a stronger scent trail is found on the investigated node, the cat moves to that node.
- If the investigated node has a weaker scent trail or no scent trail, the cat will select a random adjacent node to wander to, excluding the investigated node and the node it just left on its prior move unless it has no other option.
- If the cat's current node did not have a scent trail, the cat will randomly select an adjacent node to wander to, excluding the node it just left on its prior move unless it has no other option.
